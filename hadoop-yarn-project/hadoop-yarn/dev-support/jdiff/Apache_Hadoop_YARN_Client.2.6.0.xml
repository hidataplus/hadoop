<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Wed Apr 08 11:30:44 PDT 2015 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="hadoop-yarn-client 2.6.0"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet org.apache.hadoop.classification.tools.ExcludePrivateAnnotationsJDiffDoclet -docletpath /Users/llu/hadoop2_6/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/target/hadoop-annotations.jar:/Users/llu/hadoop2_6/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/target/jdiff.jar -verbose -classpath /Users/llu/hadoop2_6/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/target/classes:/Users/llu/.m2/repository/org/apache/hadoop/hadoop-common/2.6.0/hadoop-common-2.6.0.jar:/Users/llu/.m2/repository/org/apache/commons/commons-math3/3.1.1/commons-math3-3.1.1.jar:/Users/llu/.m2/repository/xmlenc/xmlenc/0.52/xmlenc-0.52.jar:/Users/llu/.m2/repository/commons-httpclient/commons-httpclient/3.1/commons-httpclient-3.1.jar:/Users/llu/.m2/repository/commons-codec/commons-codec/1.4/commons-codec-1.4.jar:/Users/llu/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/llu/.m2/repository/commons-net/commons-net/3.1/commons-net-3.1.jar:/Users/llu/.m2/repository/commons-collections/commons-collections/3.2.1/commons-collections-3.2.1.jar:/Users/llu/.m2/repository/javax/servlet/servlet-api/2.5/servlet-api-2.5.jar:/Users/llu/.m2/repository/org/mortbay/jetty/jetty/6.1.26/jetty-6.1.26.jar:/Users/llu/.m2/repository/org/mortbay/jetty/jetty-util/6.1.26/jetty-util-6.1.26.jar:/Users/llu/.m2/repository/com/sun/jersey/jersey-core/1.9/jersey-core-1.9.jar:/Users/llu/.m2/repository/com/sun/jersey/jersey-json/1.9/jersey-json-1.9.jar:/Users/llu/.m2/repository/com/sun/xml/bind/jaxb-impl/2.2.3-1/jaxb-impl-2.2.3-1.jar:/Users/llu/.m2/repository/com/sun/jersey/jersey-server/1.9/jersey-server-1.9.jar:/Users/llu/.m2/repository/asm/asm/3.2/asm-3.2.jar:/Users/llu/.m2/repository/javax/servlet/jsp/jsp-api/2.1/jsp-api-2.1.jar:/Users/llu/.m2/repository/net/java/dev/jets3t/jets3t/0.9.0/jets3t-0.9.0.jar:/Users/llu/.m2/repository/org/apache/httpcomponents/httpclient/4.2.5/httpclient-4.2.5.jar:/Users/llu/.m2/repository/org/apache/httpcomponents/httpcore/4.2.5/httpcore-4.2.5.jar:/Users/llu/.m2/repository/com/jamesmurty/utils/java-xmlbuilder/0.4/java-xmlbuilder-0.4.jar:/Users/llu/.m2/repository/commons-configuration/commons-configuration/1.6/commons-configuration-1.6.jar:/Users/llu/.m2/repository/commons-digester/commons-digester/1.8/commons-digester-1.8.jar:/Users/llu/.m2/repository/commons-beanutils/commons-beanutils/1.7.0/commons-beanutils-1.7.0.jar:/Users/llu/.m2/repository/commons-beanutils/commons-beanutils-core/1.8.0/commons-beanutils-core-1.8.0.jar:/Users/llu/.m2/repository/org/slf4j/slf4j-api/1.7.5/slf4j-api-1.7.5.jar:/Users/llu/.m2/repository/org/slf4j/slf4j-log4j12/1.7.5/slf4j-log4j12-1.7.5.jar:/Users/llu/.m2/repository/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar:/Users/llu/.m2/repository/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar:/Users/llu/.m2/repository/org/apache/avro/avro/1.7.4/avro-1.7.4.jar:/Users/llu/.m2/repository/com/thoughtworks/paranamer/paranamer/2.3/paranamer-2.3.jar:/Users/llu/.m2/repository/org/xerial/snappy/snappy-java/1.0.4.1/snappy-java-1.0.4.1.jar:/Users/llu/.m2/repository/com/google/protobuf/protobuf-java/2.5.0/protobuf-java-2.5.0.jar:/Users/llu/.m2/repository/com/google/code/gson/gson/2.2.4/gson-2.2.4.jar:/Users/llu/.m2/repository/org/apache/hadoop/hadoop-auth/2.6.0/hadoop-auth-2.6.0.jar:/Users/llu/.m2/repository/org/apache/directory/server/apacheds-kerberos-codec/2.0.0-M15/apacheds-kerberos-codec-2.0.0-M15.jar:/Users/llu/.m2/repository/org/apache/directory/server/apacheds-i18n/2.0.0-M15/apacheds-i18n-2.0.0-M15.jar:/Users/llu/.m2/repository/org/apache/directory/api/api-asn1-api/1.0.0-M20/api-asn1-api-1.0.0-M20.jar:/Users/llu/.m2/repository/org/apache/directory/api/api-util/1.0.0-M20/api-util-1.0.0-M20.jar:/Users/llu/.m2/repository/org/apache/curator/curator-framework/2.6.0/curator-framework-2.6.0.jar:/Users/llu/.m2/repository/com/jcraft/jsch/0.1.42/jsch-0.1.42.jar:/Users/llu/.m2/repository/org/apache/curator/curator-client/2.6.0/curator-client-2.6.0.jar:/Users/llu/.m2/repository/org/apache/curator/curator-recipes/2.6.0/curator-recipes-2.6.0.jar:/Users/llu/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/llu/.m2/repository/org/htrace/htrace-core/3.0.4/htrace-core-3.0.4.jar:/Users/llu/.m2/repository/org/apache/zookeeper/zookeeper/3.4.6/zookeeper-3.4.6.jar:/Users/llu/.m2/repository/org/apache/commons/commons-compress/1.4.1/commons-compress-1.4.1.jar:/Users/llu/.m2/repository/org/tukaani/xz/1.0/xz-1.0.jar:/Users/llu/.m2/repository/com/google/guava/guava/11.0.2/guava-11.0.2.jar:/Users/llu/.m2/repository/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar:/Users/llu/.m2/repository/commons-lang/commons-lang/2.6/commons-lang-2.6.jar:/Users/llu/.m2/repository/commons-cli/commons-cli/1.2/commons-cli-1.2.jar:/Users/llu/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/llu/.m2/repository/org/apache/hadoop/hadoop-annotations/2.6.0/hadoop-annotations-2.6.0.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_67.jdk/Contents/Home/lib/tools.jar:/Users/llu/.m2/repository/io/netty/netty/3.6.2.Final/netty-3.6.2.Final.jar:/Users/llu/hadoop2_6/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-api/target/hadoop-yarn-api-2.6.0.jar:/Users/llu/hadoop2_6/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/target/hadoop-yarn-common-2.6.0.jar:/Users/llu/.m2/repository/javax/xml/bind/jaxb-api/2.2.2/jaxb-api-2.2.2.jar:/Users/llu/.m2/repository/javax/xml/stream/stax-api/1.0-2/stax-api-1.0-2.jar:/Users/llu/.m2/repository/javax/activation/activation/1.1/activation-1.1.jar:/Users/llu/.m2/repository/com/sun/jersey/jersey-client/1.9/jersey-client-1.9.jar:/Users/llu/.m2/repository/org/codehaus/jackson/jackson-jaxrs/1.9.13/jackson-jaxrs-1.9.13.jar:/Users/llu/.m2/repository/org/codehaus/jackson/jackson-xc/1.9.13/jackson-xc-1.9.13.jar:/Users/llu/.m2/repository/com/google/inject/extensions/guice-servlet/3.0/guice-servlet-3.0.jar:/Users/llu/.m2/repository/com/google/inject/guice/3.0/guice-3.0.jar:/Users/llu/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar:/Users/llu/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/Users/llu/.m2/repository/com/sun/jersey/contribs/jersey-guice/1.9/jersey-guice-1.9.jar:/Users/llu/.m2/repository/org/codehaus/jettison/jettison/1.1/jettison-1.1.jar -sourcepath /Users/llu/hadoop2_6/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java -apidir /Users/llu/hadoop2_6/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/target/site/jdiff/xml -apiname hadoop-yarn-client 2.6.0 -->
<package name="org.apache.hadoop.yarn.client.api">
  <!-- start class org.apache.hadoop.yarn.client.api.AHSClient -->
  <class name="AHSClient" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AHSClient" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createAHSClient" return="org.apache.hadoop.yarn.client.api.AHSClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of AHSClient.]]>
      </doc>
    </method>
    <method name="getApplicationReport" return="org.apache.hadoop.yarn.api.records.ApplicationReport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of the given Application.
 </p>

 <p>
 In secure mode, <code>YARN</code> verifies access to the application, queue
 etc. before accepting the request.
 </p>

 <p>
 If the user does not have <code>VIEW_APP</code> access then the following
 fields in the report will be set to stubbed values:
 <ul>
 <li>host - set to "N/A"</li>
 <li>RPC port - set to -1</li>
 <li>client token - set to "N/A"</li>
 <li>diagnostics - set to "N/A"</li>
 <li>tracking URL - set to "N/A"</li>
 <li>original tracking URL - set to "N/A"</li>
 <li>resource usage report - all values are -1</li>
 </ul>
 </p>

 @param appId
          {@link ApplicationId} of the application that needs a report
 @return application report
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplications" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report (ApplicationReport) of all Applications in the cluster.
 </p>

 <p>
 If the user does not have <code>VIEW_APP</code> access for an application
 then the corresponding report will be filtered as described in
 {@link #getApplicationReport(ApplicationId)}.
 </p>

 @return a list of reports for all applications
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplicationAttemptReport" return="org.apache.hadoop.yarn.api.records.ApplicationAttemptReport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of the given ApplicationAttempt.
 </p>

 <p>
 In secure mode, <code>YARN</code> verifies access to the application, queue
 etc. before accepting the request.
 </p>

 @param applicationAttemptId
          {@link ApplicationAttemptId} of the application attempt that needs
          a report
 @return application attempt report
 @throws YarnException
 @throws {@link ApplicationAttemptNotFoundException} if application attempt
         not found
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplicationAttempts" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of all (ApplicationAttempts) of Application in the cluster.
 </p>

 @param applicationId
 @return a list of reports for all application attempts for specified
         application
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getContainerReport" return="org.apache.hadoop.yarn.api.records.ContainerReport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of the given Container.
 </p>

 <p>
 In secure mode, <code>YARN</code> verifies access to the application, queue
 etc. before accepting the request.
 </p>

 @param containerId
          {@link ContainerId} of the container that needs a report
 @return container report
 @throws YarnException
 @throws {@link ContainerNotFoundException} if container not found
 @throws IOException]]>
      </doc>
    </method>
    <method name="getContainers" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of all (Containers) of ApplicationAttempt in the cluster.
 </p>

 @param applicationAttemptId
 @return a list of reports of all containers for specified application
         attempt
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.AHSClient -->
  <!-- start class org.apache.hadoop.yarn.client.api.AMRMClient -->
  <class name="AMRMClient" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AMRMClient" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createAMRMClient" return="org.apache.hadoop.yarn.client.api.AMRMClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of AMRMClient.
 For usage:
 <pre>
 {@code
 AMRMClient.<T>createAMRMClientContainerRequest()
 }</pre>
 @return the newly create AMRMClient instance.]]>
      </doc>
    </method>
    <method name="registerApplicationMaster" return="org.apache.hadoop.yarn.api.protocolrecords.RegisterApplicationMasterResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appHostName" type="java.lang.String"/>
      <param name="appHostPort" type="int"/>
      <param name="appTrackingUrl" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Register the application master. This must be called before any
 other interaction
 @param appHostName Name of the host on which master is running
 @param appHostPort Port master is listening on
 @param appTrackingUrl URL at which the master info can be seen
 @return <code>RegisterApplicationMasterResponse</code>
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="allocate" return="org.apache.hadoop.yarn.api.protocolrecords.AllocateResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="progressIndicator" type="float"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Request additional containers and receive new container allocations.
 Requests made via <code>addContainerRequest</code> are sent to the
 <code>ResourceManager</code>. New containers assigned to the master are
 retrieved. Status of completed containers and node health updates are also
 retrieved. This also doubles up as a heartbeat to the ResourceManager and
 must be made periodically. The call may not always return any new
 allocations of containers. App should not make concurrent allocate
 requests. May cause request loss.

 <p>
 Note : If the user has not removed container requests that have already
 been satisfied, then the re-register may end up sending the entire
 container requests to the RM (including matched requests). Which would mean
 the RM could end up giving it a lot of new allocated containers.
 </p>

 @param progressIndicator Indicates progress made by the master
 @return the response of the allocate request
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="unregisterApplicationMaster"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appStatus" type="org.apache.hadoop.yarn.api.records.FinalApplicationStatus"/>
      <param name="appMessage" type="java.lang.String"/>
      <param name="appTrackingUrl" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Unregister the application master. This must be called in the end.
 @param appStatus Success/Failure status of the master
 @param appMessage Diagnostics message on failure
 @param appTrackingUrl New URL to get master info
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="addContainerRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="req" type="T"/>
      <doc>
      <![CDATA[Request containers for resources before calling <code>allocate</code>
 @param req Resource request]]>
      </doc>
    </method>
    <method name="removeContainerRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="req" type="T"/>
      <doc>
      <![CDATA[Remove previous container request. The previous container request may have
 already been sent to the ResourceManager. So even after the remove request
 the app must be prepared to receive an allocation for the previous request
 even after the remove request
 @param req Resource request]]>
      </doc>
    </method>
    <method name="releaseAssignedContainer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <doc>
      <![CDATA[Release containers assigned by the Resource Manager. If the app cannot use
 the container or wants to give up the container then it can release them.
 The app needs to make new requests for the released resource capability if
 it still needs it. eg. it released non-local resources
 @param containerId]]>
      </doc>
    </method>
    <method name="getAvailableResources" return="org.apache.hadoop.yarn.api.records.Resource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the currently available resources in the cluster.
 A valid value is available after a call to allocate has been made
 @return Currently available resources]]>
      </doc>
    </method>
    <method name="getClusterNodeCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current number of nodes in the cluster.
 A valid values is available after a call to allocate has been made
 @return Current number of nodes in the cluster]]>
      </doc>
    </method>
    <method name="getMatchingRequests" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="priority" type="org.apache.hadoop.yarn.api.records.Priority"/>
      <param name="resourceName" type="java.lang.String"/>
      <param name="capability" type="org.apache.hadoop.yarn.api.records.Resource"/>
      <doc>
      <![CDATA[Get outstanding <code>ContainerRequest</code>s matching the given
 parameters. These ContainerRequests should have been added via
 <code>addContainerRequest</code> earlier in the lifecycle. For performance,
 the AMRMClient may return its internal collection directly without creating
 a copy. Users should not perform mutable operations on the return value.
 Each collection in the list contains requests with identical
 <code>Resource</code> size that fit in the given capability. In a
 collection, requests will be returned in the same order as they were added.
 @return Collection of request matching the parameters]]>
      </doc>
    </method>
    <method name="updateBlacklist"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="blacklistAdditions" type="java.util.List"/>
      <param name="blacklistRemovals" type="java.util.List"/>
      <doc>
      <![CDATA[Update application's blacklist with addition or removal resources.

 @param blacklistAdditions list of resources which should be added to the
        application blacklist
 @param blacklistRemovals list of resources which should be removed from the
        application blacklist]]>
      </doc>
    </method>
    <method name="setNMTokenCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nmTokenCache" type="org.apache.hadoop.yarn.client.api.NMTokenCache"/>
      <doc>
      <![CDATA[Set the NM token cache for the <code>AMRMClient</code>. This cache must
 be shared with the {@link NMClient} used to manage containers for the
 <code>AMRMClient</code>
 <p/>
 If a NM token cache is not set, the {@link NMTokenCache#getSingleton()}
 singleton instance will be used.

 @param nmTokenCache the NM token cache to use.]]>
      </doc>
    </method>
    <method name="getNMTokenCache" return="org.apache.hadoop.yarn.client.api.NMTokenCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the NM token cache of the <code>AMRMClient</code>. This cache must be
 shared with the {@link NMClient} used to manage containers for the
 <code>AMRMClient</code>.
 <p/>
 If a NM token cache is not set, the {@link NMTokenCache#getSingleton()}
 singleton instance will be used.

 @return the NM token cache.]]>
      </doc>
    </method>
    <method name="waitFor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="check" type="com.google.common.base.Supplier"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Wait for <code>check</code> to return true for each 1000 ms.
 See also {@link #waitFor(com.google.common.base.Supplier, int)}
 and {@link #waitFor(com.google.common.base.Supplier, int, int)}
 @param check]]>
      </doc>
    </method>
    <method name="waitFor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="check" type="com.google.common.base.Supplier"/>
      <param name="checkEveryMillis" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Wait for <code>check</code> to return true for each
 <code>checkEveryMillis</code> ms.
 See also {@link #waitFor(com.google.common.base.Supplier, int, int)}
 @param check user defined checker
 @param checkEveryMillis interval to call <code>check</code>]]>
      </doc>
    </method>
    <method name="waitFor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="check" type="com.google.common.base.Supplier"/>
      <param name="checkEveryMillis" type="int"/>
      <param name="logInterval" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Wait for <code>check</code> to return true for each
 <code>checkEveryMillis</code> ms. In the main loop, this method will log
 the message "waiting in main loop" for each <code>logInterval</code> times
 iteration to confirm the thread is alive.
 @param check user defined checker
 @param checkEveryMillis interval to call <code>check</code>
 @param logInterval interval to log for each]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.AMRMClient -->
  <!-- start class org.apache.hadoop.yarn.client.api.AMRMClient.ContainerRequest -->
  <class name="AMRMClient.ContainerRequest" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AMRMClient.ContainerRequest" type="org.apache.hadoop.yarn.api.records.Resource, java.lang.String[], java.lang.String[], org.apache.hadoop.yarn.api.records.Priority"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiates a {@link ContainerRequest} with the given constraints and
 locality relaxation enabled.

 @param capability
          The {@link Resource} to be requested for each container.
 @param nodes
          Any hosts to request that the containers are placed on.
 @param racks
          Any racks to request that the containers are placed on. The
          racks corresponding to any hosts requested will be automatically
          added to this list.
 @param priority
          The priority at which to request the containers. Higher
          priorities have lower numerical values.]]>
      </doc>
    </constructor>
    <constructor name="AMRMClient.ContainerRequest" type="org.apache.hadoop.yarn.api.records.Resource, java.lang.String[], java.lang.String[], org.apache.hadoop.yarn.api.records.Priority, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiates a {@link ContainerRequest} with the given constraints.

 @param capability
          The {@link Resource} to be requested for each container.
 @param nodes
          Any hosts to request that the containers are placed on.
 @param racks
          Any racks to request that the containers are placed on. The
          racks corresponding to any hosts requested will be automatically
          added to this list.
 @param priority
          The priority at which to request the containers. Higher
          priorities have lower numerical values.
 @param relaxLocality
          If true, containers for this request may be assigned on hosts
          and racks other than the ones explicitly requested.]]>
      </doc>
    </constructor>
    <constructor name="AMRMClient.ContainerRequest" type="org.apache.hadoop.yarn.api.records.Resource, java.lang.String[], java.lang.String[], org.apache.hadoop.yarn.api.records.Priority, boolean, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiates a {@link ContainerRequest} with the given constraints.

 @param capability
          The {@link Resource} to be requested for each container.
 @param nodes
          Any hosts to request that the containers are placed on.
 @param racks
          Any racks to request that the containers are placed on. The
          racks corresponding to any hosts requested will be automatically
          added to this list.
 @param priority
          The priority at which to request the containers. Higher
          priorities have lower numerical values.
 @param relaxLocality
          If true, containers for this request may be assigned on hosts
          and racks other than the ones explicitly requested.
 @param nodeLabelsExpression
          Set node labels to allocate resource]]>
      </doc>
    </constructor>
    <method name="getCapability" return="org.apache.hadoop.yarn.api.records.Resource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNodes" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRacks" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPriority" return="org.apache.hadoop.yarn.api.records.Priority"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRelaxLocality" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNodeLabelExpression" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Object to represent a single container request for resources. Scheduler
 documentation should be consulted for the specifics of how the parameters
 are honored.

 By default, YARN schedulers try to allocate containers at the requested
 locations but they may relax the constraints in order to expedite meeting
 allocations limits. They first relax the constraint to the same rack as the
 requested node and then to anywhere in the cluster. The relaxLocality flag
 may be used to disable locality relaxation and request containers at only
 specific locations. The following conditions apply.
 <ul>
 <li>Within a priority, all container requests must have the same value for
 locality relaxation. Either enabled or disabled.</li>
 <li>If locality relaxation is disabled, then across requests, locations at
 different network levels may not be specified. E.g. its invalid to make a
 request for a specific node and another request for a specific rack.</li>
 <li>If locality relaxation is disabled, then only within the same request,
 a node and its rack may be specified together. This allows for a specific
 rack with a preference for a specific node within that rack.</li>
 <li></li>
 </ul>
 To re-enable locality relaxation at a given priority, all pending requests
 with locality relaxation disabled must be first removed. Then they can be
 added back with locality relaxation enabled.

 All getters return immutable values.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.AMRMClient.ContainerRequest -->
  <!-- start class org.apache.hadoop.yarn.client.api.InvalidContainerRequestException -->
  <class name="InvalidContainerRequestException" extends="org.apache.hadoop.yarn.exceptions.YarnRuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidContainerRequestException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="InvalidContainerRequestException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="InvalidContainerRequestException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown when an arguments are combined to construct a
 <code>AMRMClient.ContainerRequest</code> in an invalid way.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.InvalidContainerRequestException -->
  <!-- start class org.apache.hadoop.yarn.client.api.NMClient -->
  <class name="NMClient" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NMClient" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createNMClient" return="org.apache.hadoop.yarn.client.api.NMClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of NMClient.]]>
      </doc>
    </method>
    <method name="createNMClient" return="org.apache.hadoop.yarn.client.api.NMClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Create a new instance of NMClient.]]>
      </doc>
    </method>
    <method name="startContainer" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.yarn.api.records.Container"/>
      <param name="containerLaunchContext" type="org.apache.hadoop.yarn.api.records.ContainerLaunchContext"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Start an allocated container.</p>

 <p>The <code>ApplicationMaster</code> or other applications that use the
 client must provide the details of the allocated container, including the
 Id, the assigned node's Id and the token via {@link Container}. In
 addition, the AM needs to provide the {@link ContainerLaunchContext} as
 well.</p>

 @param container the allocated container
 @param containerLaunchContext the context information needed by the
                               <code>NodeManager</code> to launch the
                               container
 @return a map between the auxiliary service names and their outputs
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="stopContainer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="nodeId" type="org.apache.hadoop.yarn.api.records.NodeId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Stop an started container.</p>

 @param containerId the Id of the started container
 @param nodeId the Id of the <code>NodeManager</code>

 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getContainerStatus" return="org.apache.hadoop.yarn.api.records.ContainerStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="nodeId" type="org.apache.hadoop.yarn.api.records.NodeId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Query the status of a container.</p>

 @param containerId the Id of the started container
 @param nodeId the Id of the <code>NodeManager</code>

 @return the status of a container
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="cleanupRunningContainersOnStop"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="enabled" type="boolean"/>
      <doc>
      <![CDATA[<p>Set whether the containers that are started by this client, and are
 still running should be stopped when the client stops. By default, the
 feature should be enabled.</p> However, containers will be stopped only
 when service is stopped. i.e. after {@link NMClient#stop()}.

 @param enabled whether the feature is enabled or not]]>
      </doc>
    </method>
    <method name="setNMTokenCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nmTokenCache" type="org.apache.hadoop.yarn.client.api.NMTokenCache"/>
      <doc>
      <![CDATA[Set the NM Token cache of the <code>NMClient</code>. This cache must be
 shared with the {@link AMRMClient} that requested the containers managed
 by this <code>NMClient</code>
 <p/>
 If a NM token cache is not set, the {@link NMTokenCache#getSingleton()}
 singleton instance will be used.

 @param nmTokenCache the NM token cache to use.]]>
      </doc>
    </method>
    <method name="getNMTokenCache" return="org.apache.hadoop.yarn.client.api.NMTokenCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the NM token cache of the <code>NMClient</code>. This cache must be
 shared with the {@link AMRMClient} that requested the containers managed
 by this <code>NMClient</code>
 <p/>
 If a NM token cache is not set, the {@link NMTokenCache#getSingleton()}
 singleton instance will be used.

 @return the NM token cache]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.NMClient -->
  <!-- start class org.apache.hadoop.yarn.client.api.NMTokenCache -->
  <class name="NMTokenCache" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NMTokenCache"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a NM token cache instance.]]>
      </doc>
    </constructor>
    <method name="getSingleton" return="org.apache.hadoop.yarn.client.api.NMTokenCache"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the singleton NM token cache.

 @return the singleton NM token cache.]]>
      </doc>
    </method>
    <method name="getNMToken" return="org.apache.hadoop.yarn.api.records.Token"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeAddr" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns NMToken, null if absent. Only the singleton obtained from
 {@link #getSingleton()} is looked at for the tokens. If you are using your
 own NMTokenCache that is different from the singleton, use
 {@link #getToken(String) }

 @param nodeAddr
 @return {@link Token} NMToken required for communicating with node manager]]>
      </doc>
    </method>
    <method name="setNMToken"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeAddr" type="java.lang.String"/>
      <param name="token" type="org.apache.hadoop.yarn.api.records.Token"/>
      <doc>
      <![CDATA[Sets the NMToken for node address only in the singleton obtained from
 {@link #getSingleton()}. If you are using your own NMTokenCache that is
 different from the singleton, use {@link #setToken(String, Token) }

 @param nodeAddr
          node address (host:port)
 @param token
          NMToken]]>
      </doc>
    </method>
    <method name="getToken" return="org.apache.hadoop.yarn.api.records.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeAddr" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns NMToken, null if absent
 @param nodeAddr
 @return {@link Token} NMToken required for communicating with node
         manager]]>
      </doc>
    </method>
    <method name="setToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeAddr" type="java.lang.String"/>
      <param name="token" type="org.apache.hadoop.yarn.api.records.Token"/>
      <doc>
      <![CDATA[Sets the NMToken for node address
 @param nodeAddr node address (host:port)
 @param token NMToken]]>
      </doc>
    </method>
    <doc>
    <![CDATA[NMTokenCache manages NMTokens required for an Application Master
 communicating with individual NodeManagers.
 <p/>
 By default Yarn client libraries {@link AMRMClient} and {@link NMClient} use
 {@link #getSingleton()} instance of the cache.
 <ul>
 <li>Using the singleton instance of the cache is appropriate when running a
 single ApplicationMaster in the same JVM.</li>
 <li>When using the singleton, users don't need to do anything special,
 {@link AMRMClient} and {@link NMClient} are already set up to use the default
 singleton {@link NMTokenCache}</li>
 </ul>
 <p/>
 If running multiple Application Masters in the same JVM, a different cache
 instance should be used for each Application Master.
 <p/>
 <ul>
 <li>
 If using the {@link AMRMClient} and the {@link NMClient}, setting up and using
 an instance cache is as follows:
 <p/>

 <pre>
   NMTokenCache nmTokenCache = new NMTokenCache();
   AMRMClient rmClient = AMRMClient.createAMRMClient();
   NMClient nmClient = NMClient.createNMClient();
   nmClient.setNMTokenCache(nmTokenCache);
   ...
 </pre>
 </li>
 <li>
 If using the {@link AMRMClientAsync} and the {@link NMClientAsync}, setting up
 and using an instance cache is as follows:
 <p/>

 <pre>
   NMTokenCache nmTokenCache = new NMTokenCache();
   AMRMClient rmClient = AMRMClient.createAMRMClient();
   NMClient nmClient = NMClient.createNMClient();
   nmClient.setNMTokenCache(nmTokenCache);
   AMRMClientAsync rmClientAsync = new AMRMClientAsync(rmClient, 1000, [AMRM_CALLBACK]);
   NMClientAsync nmClientAsync = new NMClientAsync("nmClient", nmClient, [NM_CALLBACK]);
   ...
 </pre>
 </li>
 <li>
 If using {@link ApplicationMasterProtocol} and
 {@link ContainerManagementProtocol} directly, setting up and using an
 instance cache is as follows:
 <p/>

 <pre>
   NMTokenCache nmTokenCache = new NMTokenCache();
   ...
   ApplicationMasterProtocol amPro = ClientRMProxy.createRMProxy(conf, ApplicationMasterProtocol.class);
   ...
   AllocateRequest allocateRequest = ...
   ...
   AllocateResponse allocateResponse = rmClient.allocate(allocateRequest);
   for (NMToken token : allocateResponse.getNMTokens()) {
     nmTokenCache.setToken(token.getNodeId().toString(), token.getToken());
   }
   ...
   ContainerManagementProtocolProxy nmPro = ContainerManagementProtocolProxy(conf, nmTokenCache);
   ...
   nmPro.startContainer(container, containerContext);
   ...
 </pre>
 </li>
 </ul>
 It is also possible to mix the usage of a client (<code>AMRMClient</code> or
 <code>NMClient</code>, or the async versions of them) with a protocol proxy (
 <code>ContainerManagementProtocolProxy</code> or
 <code>ApplicationMasterProtocol</code>).]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.NMTokenCache -->
  <!-- start class org.apache.hadoop.yarn.client.api.YarnClient -->
  <class name="YarnClient" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="YarnClient" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createYarnClient" return="org.apache.hadoop.yarn.client.api.YarnClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of YarnClient.]]>
      </doc>
    </method>
    <method name="createApplication" return="org.apache.hadoop.yarn.client.api.YarnClientApplication"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Obtain a {@link YarnClientApplication} for a new application,
 which in turn contains the {@link ApplicationSubmissionContext} and
 {@link org.apache.hadoop.yarn.api.protocolrecords.GetNewApplicationResponse}
 objects.
 </p>

 @return {@link YarnClientApplication} built for a new application
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="submitApplication" return="org.apache.hadoop.yarn.api.records.ApplicationId"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appContext" type="org.apache.hadoop.yarn.api.records.ApplicationSubmissionContext"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Submit a new application to <code>YARN.</code> It is a blocking call - it
 will not return {@link ApplicationId} until the submitted application is
 submitted successfully and accepted by the ResourceManager.
 </p>

 <p>
 Users should provide an {@link ApplicationId} as part of the parameter
 {@link ApplicationSubmissionContext} when submitting a new application,
 otherwise it will throw the {@link ApplicationIdNotProvidedException}.
 </p>

 <p>This internally calls {@link ApplicationClientProtocol#submitApplication
 (SubmitApplicationRequest)}, and after that, it internally invokes
 {@link ApplicationClientProtocol#getApplicationReport
 (GetApplicationReportRequest)} and waits till it can make sure that the
 application gets properly submitted. If RM fails over or RM restart
 happens before ResourceManager saves the application's state,
 {@link ApplicationClientProtocol
 #getApplicationReport(GetApplicationReportRequest)} will throw
 the {@link ApplicationNotFoundException}. This API automatically resubmits
 the application with the same {@link ApplicationSubmissionContext} when it
 catches the {@link ApplicationNotFoundException}</p>

 @param appContext
          {@link ApplicationSubmissionContext} containing all the details
          needed to submit a new application
 @return {@link ApplicationId} of the accepted application
 @throws YarnException
 @throws IOException
 @see #createApplication()]]>
      </doc>
    </method>
    <method name="killApplication"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Kill an application identified by given ID.
 </p>

 @param applicationId
          {@link ApplicationId} of the application that needs to be killed
 @throws YarnException
           in case of errors or if YARN rejects the request due to
           access-control restrictions.
 @throws IOException
 @see #getQueueAclsInfo()]]>
      </doc>
    </method>
    <method name="getApplicationReport" return="org.apache.hadoop.yarn.api.records.ApplicationReport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of the given Application.
 </p>

 <p>
 In secure mode, <code>YARN</code> verifies access to the application, queue
 etc. before accepting the request.
 </p>

 <p>
 If the user does not have <code>VIEW_APP</code> access then the following
 fields in the report will be set to stubbed values:
 <ul>
 <li>host - set to "N/A"</li>
 <li>RPC port - set to -1</li>
 <li>client token - set to "N/A"</li>
 <li>diagnostics - set to "N/A"</li>
 <li>tracking URL - set to "N/A"</li>
 <li>original tracking URL - set to "N/A"</li>
 <li>resource usage report - all values are -1</li>
 </ul>
 </p>

 @param appId
          {@link ApplicationId} of the application that needs a report
 @return application report
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getAMRMToken" return="org.apache.hadoop.security.token.Token"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the AMRM token of the application.
 <p/>
 The AMRM token is required for AM to RM scheduling operations. For
 managed Application Masters Yarn takes care of injecting it. For unmanaged
 Applications Masters, the token must be obtained via this method and set
 in the {@link org.apache.hadoop.security.UserGroupInformation} of the
 current user.
 <p/>
 The AMRM token will be returned only if all the following conditions are
 met:
 <li>
   <ul>the requester is the owner of the ApplicationMaster</ul>
   <ul>the application master is an unmanaged ApplicationMaster</ul>
   <ul>the application master is in ACCEPTED state</ul>
 </li>
 Else this method returns NULL.

 @param appId {@link ApplicationId} of the application to get the AMRM token
 @return the AMRM token if available
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplications" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report (ApplicationReport) of all Applications in the cluster.
 </p>

 <p>
 If the user does not have <code>VIEW_APP</code> access for an application
 then the corresponding report will be filtered as described in
 {@link #getApplicationReport(ApplicationId)}.
 </p>

 @return a list of reports of all running applications
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplications" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationTypes" type="java.util.Set"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report (ApplicationReport) of Applications
 matching the given application types in the cluster.
 </p>

 <p>
 If the user does not have <code>VIEW_APP</code> access for an application
 then the corresponding report will be filtered as described in
 {@link #getApplicationReport(ApplicationId)}.
 </p>

 @param applicationTypes
 @return a list of reports of applications
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplications" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationStates" type="java.util.EnumSet"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report (ApplicationReport) of Applications matching the given
 application states in the cluster.
 </p>

 <p>
 If the user does not have <code>VIEW_APP</code> access for an application
 then the corresponding report will be filtered as described in
 {@link #getApplicationReport(ApplicationId)}.
 </p>

 @param applicationStates
 @return a list of reports of applications
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplications" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationTypes" type="java.util.Set"/>
      <param name="applicationStates" type="java.util.EnumSet"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report (ApplicationReport) of Applications matching the given
 application types and application states in the cluster.
 </p>

 <p>
 If the user does not have <code>VIEW_APP</code> access for an application
 then the corresponding report will be filtered as described in
 {@link #getApplicationReport(ApplicationId)}.
 </p>

 @param applicationTypes
 @param applicationStates
 @return a list of reports of applications
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getYarnClusterMetrics" return="org.apache.hadoop.yarn.api.records.YarnClusterMetrics"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get metrics ({@link YarnClusterMetrics}) about the cluster.
 </p>

 @return cluster metrics
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getNodeReports" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="states" type="org.apache.hadoop.yarn.api.records.NodeState[]"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of nodes ({@link NodeReport}) in the cluster.
 </p>

 @param states The {@link NodeState}s to filter on. If no filter states are
          given, nodes in all states will be returned.
 @return A list of node reports
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getRMDelegationToken" return="org.apache.hadoop.yarn.api.records.Token"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renewer" type="org.apache.hadoop.io.Text"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a delegation token so as to be able to talk to YARN using those tokens.

 @param renewer
          Address of the renewer who can renew these tokens when needed by
          securely talking to YARN.
 @return a delegation token ({@link Token}) that can be used to
         talk to YARN
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getQueueInfo" return="org.apache.hadoop.yarn.api.records.QueueInfo"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queueName" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get information ({@link QueueInfo}) about a given <em>queue</em>.
 </p>

 @param queueName
          Name of the queue whose information is needed
 @return queue information
 @throws YarnException
           in case of errors or if YARN rejects the request due to
           access-control restrictions.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getAllQueues" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get information ({@link QueueInfo}) about all queues, recursively if there
 is a hierarchy
 </p>

 @return a list of queue-information for all queues
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getRootQueueInfos" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get information ({@link QueueInfo}) about top level queues.
 </p>

 @return a list of queue-information for all the top-level queues
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getChildQueueInfos" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get information ({@link QueueInfo}) about all the immediate children queues
 of the given queue
 </p>

 @param parent
          Name of the queue whose child-queues' information is needed
 @return a list of queue-information for all queues who are direct children
         of the given parent queue.
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getQueueAclsInfo" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get information about <em>acls</em> for <em>current user</em> on all the
 existing queues.
 </p>

 @return a list of queue acls ({@link QueueUserACLInfo}) for
         <em>current user</em>
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplicationAttemptReport" return="org.apache.hadoop.yarn.api.records.ApplicationAttemptReport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of the given ApplicationAttempt.
 </p>

 <p>
 In secure mode, <code>YARN</code> verifies access to the application, queue
 etc. before accepting the request.
 </p>

 @param applicationAttemptId
          {@link ApplicationAttemptId} of the application attempt that needs
          a report
 @return application attempt report
 @throws YarnException
 @throws {@link ApplicationAttemptNotFoundException} if application attempt
         not found
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplicationAttempts" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of all (ApplicationAttempts) of Application in the cluster.
 </p>

 @param applicationId
 @return a list of reports for all application attempts for specified
         application.
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getContainerReport" return="org.apache.hadoop.yarn.api.records.ContainerReport"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of the given Container.
 </p>

 <p>
 In secure mode, <code>YARN</code> verifies access to the application, queue
 etc. before accepting the request.
 </p>

 @param containerId
          {@link ContainerId} of the container that needs a report
 @return container report
 @throws YarnException
 @throws {@link ContainerNotFoundException} if container not found.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getContainers" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Get a report of all (Containers) of ApplicationAttempt in the cluster.
 </p>

 @param applicationAttemptId
 @return a list of reports of all containers for specified application
         attempts
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="moveApplicationAcrossQueues"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="queue" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Attempts to move the given application to the given queue.
 </p>

 @param appId
    Application to move.
 @param queue
    Queue to place it in to.
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="submitReservation" return="org.apache.hadoop.yarn.api.protocolrecords.ReservationSubmissionResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="org.apache.hadoop.yarn.api.protocolrecords.ReservationSubmissionRequest"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 The interface used by clients to submit a new reservation to the
 {@code ResourceManager}.
 </p>

 <p>
 The client packages all details of its request in a
 {@link ReservationSubmissionRequest} object. This contains information
 about the amount of capacity, temporal constraints, and gang needs.
 Furthermore, the reservation might be composed of multiple stages, with
 ordering dependencies among them.
 </p>

 <p>
 In order to respond, a new admission control component in the
 {@code ResourceManager} performs an analysis of the resources that have
 been committed over the period of time the user is requesting, verify that
 the user requests can be fulfilled, and that it respect a sharing policy
 (e.g., {@code CapacityOverTimePolicy}). Once it has positively determined
 that the ReservationRequest is satisfiable the {@code ResourceManager}
 answers with a {@link ReservationSubmissionResponse} that includes a
 {@link ReservationId}. Upon failure to find a valid allocation the response
 is an exception with the message detailing the reason of failure.
 </p>

 <p>
 The semantics guarantees that the {@link ReservationId} returned,
 corresponds to a valid reservation existing in the time-range request by
 the user. The amount of capacity dedicated to such reservation can vary
 overtime, depending of the allocation that has been determined. But it is
 guaranteed to satisfy all the constraint expressed by the user in the
 {@link ReservationDefinition}
 </p>

 @param request request to submit a new Reservation
 @return response contains the {@link ReservationId} on accepting the
         submission
 @throws YarnException if the reservation cannot be created successfully
 @throws IOException]]>
      </doc>
    </method>
    <method name="updateReservation" return="org.apache.hadoop.yarn.api.protocolrecords.ReservationUpdateResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="org.apache.hadoop.yarn.api.protocolrecords.ReservationUpdateRequest"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 The interface used by clients to update an existing Reservation. This is
 referred to as a re-negotiation process, in which a user that has
 previously submitted a Reservation.
 </p>

 <p>
 The allocation is attempted by virtually substituting all previous
 allocations related to this Reservation with new ones, that satisfy the new
 {@link ReservationDefinition}. Upon success the previous allocation is
 atomically substituted by the new one, and on failure (i.e., if the system
 cannot find a valid allocation for the updated request), the previous
 allocation remains valid.
 </p>

 @param request to update an existing Reservation (the
          {@link ReservationUpdateRequest} should refer to an existing valid
          {@link ReservationId})
 @return response empty on successfully updating the existing reservation
 @throws YarnException if the request is invalid or reservation cannot be
           updated successfully
 @throws IOException]]>
      </doc>
    </method>
    <method name="deleteReservation" return="org.apache.hadoop.yarn.api.protocolrecords.ReservationDeleteResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="org.apache.hadoop.yarn.api.protocolrecords.ReservationDeleteRequest"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 The interface used by clients to remove an existing Reservation.
 </p>

 @param request to remove an existing Reservation (the
          {@link ReservationDeleteRequest} should refer to an existing valid
          {@link ReservationId})
 @return response empty on successfully deleting the existing reservation
 @throws YarnException if the request is invalid or reservation cannot be
           deleted successfully
 @throws IOException]]>
      </doc>
    </method>
    <method name="getNodeToLabels" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 The interface used by client to get node to labels mappings in existing cluster
 </p>

 @return node to labels mappings
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="getClusterNodeLabels" return="java.util.Set"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 The interface used by client to get node labels in the cluster
 </p>

 @return cluster node labels collection
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.YarnClient -->
  <!-- start class org.apache.hadoop.yarn.client.api.YarnClientApplication -->
  <class name="YarnClientApplication" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="YarnClientApplication" type="org.apache.hadoop.yarn.api.protocolrecords.GetNewApplicationResponse, org.apache.hadoop.yarn.api.records.ApplicationSubmissionContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNewApplicationResponse" return="org.apache.hadoop.yarn.api.protocolrecords.GetNewApplicationResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getApplicationSubmissionContext" return="org.apache.hadoop.yarn.api.records.ApplicationSubmissionContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.YarnClientApplication -->
</package>
<package name="org.apache.hadoop.yarn.client.api.async">
  <!-- start class org.apache.hadoop.yarn.client.api.async.AMRMClientAsync -->
  <class name="AMRMClientAsync" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AMRMClientAsync" type="int, org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.CallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AMRMClientAsync" type="org.apache.hadoop.yarn.client.api.AMRMClient, int, org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.CallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createAMRMClientAsync" return="org.apache.hadoop.yarn.client.api.async.AMRMClientAsync"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="intervalMs" type="int"/>
      <param name="callbackHandler" type="org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.CallbackHandler"/>
    </method>
    <method name="createAMRMClientAsync" return="org.apache.hadoop.yarn.client.api.async.AMRMClientAsync"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="client" type="org.apache.hadoop.yarn.client.api.AMRMClient"/>
      <param name="intervalMs" type="int"/>
      <param name="callbackHandler" type="org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.CallbackHandler"/>
    </method>
    <method name="setHeartbeatInterval"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interval" type="int"/>
    </method>
    <method name="getMatchingRequests" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="priority" type="org.apache.hadoop.yarn.api.records.Priority"/>
      <param name="resourceName" type="java.lang.String"/>
      <param name="capability" type="org.apache.hadoop.yarn.api.records.Resource"/>
    </method>
    <method name="registerApplicationMaster" return="org.apache.hadoop.yarn.api.protocolrecords.RegisterApplicationMasterResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appHostName" type="java.lang.String"/>
      <param name="appHostPort" type="int"/>
      <param name="appTrackingUrl" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Registers this application master with the resource manager. On successful
 registration, starts the heartbeating thread.
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="unregisterApplicationMaster"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appStatus" type="org.apache.hadoop.yarn.api.records.FinalApplicationStatus"/>
      <param name="appMessage" type="java.lang.String"/>
      <param name="appTrackingUrl" type="java.lang.String"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Unregister the application master. This must be called in the end.
 @param appStatus Success/Failure status of the master
 @param appMessage Diagnostics message on failure
 @param appTrackingUrl New URL to get master info
 @throws YarnException
 @throws IOException]]>
      </doc>
    </method>
    <method name="addContainerRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="req" type="T"/>
      <doc>
      <![CDATA[Request containers for resources before calling <code>allocate</code>
 @param req Resource request]]>
      </doc>
    </method>
    <method name="removeContainerRequest"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="req" type="T"/>
      <doc>
      <![CDATA[Remove previous container request. The previous container request may have
 already been sent to the ResourceManager. So even after the remove request
 the app must be prepared to receive an allocation for the previous request
 even after the remove request
 @param req Resource request]]>
      </doc>
    </method>
    <method name="releaseAssignedContainer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <doc>
      <![CDATA[Release containers assigned by the Resource Manager. If the app cannot use
 the container or wants to give up the container then it can release them.
 The app needs to make new requests for the released resource capability if
 it still needs it. eg. it released non-local resources
 @param containerId]]>
      </doc>
    </method>
    <method name="getAvailableResources" return="org.apache.hadoop.yarn.api.records.Resource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the currently available resources in the cluster.
 A valid value is available after a call to allocate has been made
 @return Currently available resources]]>
      </doc>
    </method>
    <method name="getClusterNodeCount" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current number of nodes in the cluster.
 A valid values is available after a call to allocate has been made
 @return Current number of nodes in the cluster]]>
      </doc>
    </method>
    <method name="waitFor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="check" type="com.google.common.base.Supplier"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Wait for <code>check</code> to return true for each 1000 ms.
 See also {@link #waitFor(com.google.common.base.Supplier, int)}
 and {@link #waitFor(com.google.common.base.Supplier, int, int)}
 @param check]]>
      </doc>
    </method>
    <method name="waitFor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="check" type="com.google.common.base.Supplier"/>
      <param name="checkEveryMillis" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Wait for <code>check</code> to return true for each
 <code>checkEveryMillis</code> ms.
 See also {@link #waitFor(com.google.common.base.Supplier, int, int)}
 @param check user defined checker
 @param checkEveryMillis interval to call <code>check</code>]]>
      </doc>
    </method>
    <method name="waitFor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="check" type="com.google.common.base.Supplier"/>
      <param name="checkEveryMillis" type="int"/>
      <param name="logInterval" type="int"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Wait for <code>check</code> to return true for each
 <code>checkEveryMillis</code> ms. In the main loop, this method will log
 the message "waiting in main loop" for each <code>logInterval</code> times
 iteration to confirm the thread is alive.
 @param check user defined checker
 @param checkEveryMillis interval to call <code>check</code>
 @param logInterval interval to log for each]]>
      </doc>
    </method>
    <field name="client" type="org.apache.hadoop.yarn.client.api.AMRMClient"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="handler" type="org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.CallbackHandler"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="heartbeatIntervalMs" type="java.util.concurrent.atomic.AtomicInteger"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[<code>AMRMClientAsync</code> handles communication with the ResourceManager
 and provides asynchronous updates on events such as container allocations and
 completions.  It contains a thread that sends periodic heartbeats to the
 ResourceManager.

 It should be used by implementing a CallbackHandler:
 <pre>
 {@code
 class MyCallbackHandler implements AMRMClientAsync.CallbackHandler {
   public void onContainersAllocated(List<Container> containers) {
     [run tasks on the containers]
   }

   public void onContainersCompleted(List<ContainerStatus> statuses) {
     [update progress, check whether app is done]
   }

   public void onNodesUpdated(List<NodeReport> updated) {}

   public void onReboot() {}
 }
 }
 </pre>

 The client's lifecycle should be managed similarly to the following:

 <pre>
 {@code
 AMRMClientAsync asyncClient =
     createAMRMClientAsync(appAttId, 1000, new MyCallbackhandler());
 asyncClient.init(conf);
 asyncClient.start();
 RegisterApplicationMasterResponse response = asyncClient
    .registerApplicationMaster(appMasterHostname, appMasterRpcPort,
       appMasterTrackingUrl);
 asyncClient.addContainerRequest(containerRequest);
 [... wait for application to complete]
 asyncClient.unregisterApplicationMaster(status, appMsg, trackingUrl);
 asyncClient.stop();
 }
 </pre>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.async.AMRMClientAsync -->
  <!-- start interface org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.CallbackHandler -->
  <interface name="AMRMClientAsync.CallbackHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onContainersCompleted"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statuses" type="java.util.List"/>
      <doc>
      <![CDATA[Called when the ResourceManager responds to a heartbeat with completed
 containers. If the response contains both completed containers and
 allocated containers, this will be called before containersAllocated.]]>
      </doc>
    </method>
    <method name="onContainersAllocated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containers" type="java.util.List"/>
      <doc>
      <![CDATA[Called when the ResourceManager responds to a heartbeat with allocated
 containers. If the response containers both completed containers and
 allocated containers, this will be called after containersCompleted.]]>
      </doc>
    </method>
    <method name="onShutdownRequest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called when the ResourceManager wants the ApplicationMaster to shutdown
 for being out of sync etc. The ApplicationMaster should not unregister
 with the RM unless the ApplicationMaster wants to be the last attempt.]]>
      </doc>
    </method>
    <method name="onNodesUpdated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="updatedNodes" type="java.util.List"/>
      <doc>
      <![CDATA[Called when nodes tracked by the ResourceManager have changed in health,
 availability etc.]]>
      </doc>
    </method>
    <method name="getProgress" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="onError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Called when error comes from RM communications as well as from errors in
 the callback itself from the app. Calling
 stop() is the recommended action.

 @param e]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.client.api.async.AMRMClientAsync.CallbackHandler -->
  <!-- start class org.apache.hadoop.yarn.client.api.async.NMClientAsync -->
  <class name="NMClientAsync" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NMClientAsync" type="org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="NMClientAsync" type="java.lang.String, org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="NMClientAsync" type="java.lang.String, org.apache.hadoop.yarn.client.api.NMClient, org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createNMClientAsync" return="org.apache.hadoop.yarn.client.api.async.NMClientAsync"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callbackHandler" type="org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler"/>
    </method>
    <method name="startContainerAsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.yarn.api.records.Container"/>
      <param name="containerLaunchContext" type="org.apache.hadoop.yarn.api.records.ContainerLaunchContext"/>
    </method>
    <method name="stopContainerAsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="nodeId" type="org.apache.hadoop.yarn.api.records.NodeId"/>
    </method>
    <method name="getContainerStatusAsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="nodeId" type="org.apache.hadoop.yarn.api.records.NodeId"/>
    </method>
    <method name="getClient" return="org.apache.hadoop.yarn.client.api.NMClient"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setClient"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="client" type="org.apache.hadoop.yarn.client.api.NMClient"/>
    </method>
    <method name="getCallbackHandler" return="org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCallbackHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callbackHandler" type="org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler"/>
    </method>
    <field name="client" type="org.apache.hadoop.yarn.client.api.NMClient"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="callbackHandler" type="org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[<code>NMClientAsync</code> handles communication with all the NodeManagers
 and provides asynchronous updates on getting responses from them. It
 maintains a thread pool to communicate with individual NMs where a number of
 worker threads process requests to NMs by using {@link NMClientImpl}. The max
 size of the thread pool is configurable through
 {@link YarnConfiguration#NM_CLIENT_ASYNC_THREAD_POOL_MAX_SIZE}.

 It should be used in conjunction with a CallbackHandler. For example

 <pre>
 {@code
 class MyCallbackHandler implements NMClientAsync.CallbackHandler {
   public void onContainerStarted(ContainerId containerId,
       Map<String, ByteBuffer> allServiceResponse) {
     [post process after the container is started, process the response]
   }

   public void onContainerStatusReceived(ContainerId containerId,
       ContainerStatus containerStatus) {
     [make use of the status of the container]
   }

   public void onContainerStopped(ContainerId containerId) {
     [post process after the container is stopped]
   }

   public void onStartContainerError(
       ContainerId containerId, Throwable t) {
     [handle the raised exception]
   }

   public void onGetContainerStatusError(
       ContainerId containerId, Throwable t) {
     [handle the raised exception]
   }

   public void onStopContainerError(
       ContainerId containerId, Throwable t) {
     [handle the raised exception]
   }
 }
 }
 </pre>

 The client's life-cycle should be managed like the following:

 <pre>
 {@code
 NMClientAsync asyncClient =
     NMClientAsync.createNMClientAsync(new MyCallbackhandler());
 asyncClient.init(conf);
 asyncClient.start();
 asyncClient.startContainer(container, containerLaunchContext);
 [... wait for container being started]
 asyncClient.getContainerStatus(container.getId(), container.getNodeId(),
     container.getContainerToken());
 [... handle the status in the callback instance]
 asyncClient.stopContainer(container.getId(), container.getNodeId(),
     container.getContainerToken());
 [... wait for container being stopped]
 asyncClient.stop();
 }
 </pre>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.async.NMClientAsync -->
  <!-- start interface org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler -->
  <interface name="NMClientAsync.CallbackHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onContainerStarted"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="allServiceResponse" type="java.util.Map"/>
      <doc>
      <![CDATA[The API is called when <code>NodeManager</code> responds to indicate its
 acceptance of the starting container request
 @param containerId the Id of the container
 @param allServiceResponse a Map between the auxiliary service names and
                           their outputs]]>
      </doc>
    </method>
    <method name="onContainerStatusReceived"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="containerStatus" type="org.apache.hadoop.yarn.api.records.ContainerStatus"/>
      <doc>
      <![CDATA[The API is called when <code>NodeManager</code> responds with the status
 of the container
 @param containerId the Id of the container
 @param containerStatus the status of the container]]>
      </doc>
    </method>
    <method name="onContainerStopped"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <doc>
      <![CDATA[The API is called when <code>NodeManager</code> responds to indicate the
 container is stopped.
 @param containerId the Id of the container]]>
      </doc>
    </method>
    <method name="onStartContainerError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[The API is called when an exception is raised in the process of
 starting a container

 @param containerId the Id of the container
 @param t the raised exception]]>
      </doc>
    </method>
    <method name="onGetContainerStatusError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[The API is called when an exception is raised in the process of
 querying the status of a container

 @param containerId the Id of the container
 @param t the raised exception]]>
      </doc>
    </method>
    <method name="onStopContainerError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="t" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[The API is called when an exception is raised in the process of
 stopping a container

 @param containerId the Id of the container
 @param t the raised exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 The callback interface needs to be implemented by {@link NMClientAsync}
 users. The APIs are called when responses from <code>NodeManager</code> are
 available.
 </p>

 <p>
 Once a callback happens, the users can chose to act on it in blocking or
 non-blocking manner. If the action on callback is done in a blocking
 manner, some of the threads performing requests on NodeManagers may get
 blocked depending on how many threads in the pool are busy.
 </p>

 <p>
 The implementation of the callback function should not throw the
 unexpected exception. Otherwise, {@link NMClientAsync} will just
 catch, log and then ignore it.
 </p>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.client.api.async.NMClientAsync.CallbackHandler -->
</package>
<package name="org.apache.hadoop.yarn.client.api.async.impl">
  <!-- start class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEvent -->
  <class name="NMClientAsyncImpl.ContainerEvent" extends="org.apache.hadoop.yarn.event.AbstractEvent"
    abstract="false"
    static="true" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="NMClientAsyncImpl.ContainerEvent" type="org.apache.hadoop.yarn.api.records.ContainerId, org.apache.hadoop.yarn.api.records.NodeId, org.apache.hadoop.yarn.api.records.Token, org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEventType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContainerId" return="org.apache.hadoop.yarn.api.records.ContainerId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNodeId" return="org.apache.hadoop.yarn.api.records.NodeId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getContainerToken" return="org.apache.hadoop.yarn.api.records.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEvent -->
  <!-- start class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEventProcessor -->
  <class name="NMClientAsyncImpl.ContainerEventProcessor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <implements name="java.lang.Runnable"/>
    <constructor name="NMClientAsyncImpl.ContainerEventProcessor" type="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEvent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="event" type="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEvent"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEventProcessor -->
  <!-- start class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEventType -->
  <class name="NMClientAsyncImpl.ContainerEventType" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="protected"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEventType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEventType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The type of the event of interacting with a container]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEventType -->
  <!-- start class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerState -->
  <class name="NMClientAsyncImpl.ContainerState" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="protected"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerState[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerState -->
  <!-- start class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.StartContainerEvent -->
  <class name="NMClientAsyncImpl.StartContainerEvent" extends="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEvent"
    abstract="false"
    static="true" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="NMClientAsyncImpl.StartContainerEvent" type="org.apache.hadoop.yarn.api.records.Container, org.apache.hadoop.yarn.api.records.ContainerLaunchContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContainer" return="org.apache.hadoop.yarn.api.records.Container"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getContainerLaunchContext" return="org.apache.hadoop.yarn.api.records.ContainerLaunchContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.StartContainerEvent -->
  <!-- start class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.StatefulContainer -->
  <class name="NMClientAsyncImpl.StatefulContainer" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="protected"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.yarn.event.EventHandler"/>
    <constructor name="NMClientAsyncImpl.StatefulContainer" type="org.apache.hadoop.yarn.client.api.async.NMClientAsync, org.apache.hadoop.yarn.api.records.ContainerId"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="handle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEvent"/>
    </method>
    <method name="getContainerId" return="org.apache.hadoop.yarn.api.records.ContainerId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getState" return="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="stateMachineFactory" type="org.apache.hadoop.yarn.state.StateMachineFactory"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.StatefulContainer -->
  <!-- start class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.StatefulContainer.OutOfOrderTransition -->
  <class name="NMClientAsyncImpl.StatefulContainer.OutOfOrderTransition" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="protected"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.yarn.state.SingleArcTransition"/>
    <constructor name="NMClientAsyncImpl.StatefulContainer.OutOfOrderTransition"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="transition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.StatefulContainer"/>
      <param name="event" type="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEvent"/>
    </method>
    <field name="STOP_BEFORE_START_ERROR_MSG" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.StatefulContainer.OutOfOrderTransition -->
  <!-- start class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.StatefulContainer.StartContainerTransition -->
  <class name="NMClientAsyncImpl.StatefulContainer.StartContainerTransition" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="protected"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.yarn.state.MultipleArcTransition"/>
    <constructor name="NMClientAsyncImpl.StatefulContainer.StartContainerTransition"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="transition" return="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.StatefulContainer"/>
      <param name="event" type="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEvent"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.StatefulContainer.StartContainerTransition -->
  <!-- start class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.StatefulContainer.StopContainerTransition -->
  <class name="NMClientAsyncImpl.StatefulContainer.StopContainerTransition" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="protected"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.yarn.state.MultipleArcTransition"/>
    <constructor name="NMClientAsyncImpl.StatefulContainer.StopContainerTransition"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="transition" return="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.StatefulContainer"/>
      <param name="event" type="org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.ContainerEvent"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.async.impl.NMClientAsyncImpl.StatefulContainer.StopContainerTransition -->
</package>
<package name="org.apache.hadoop.yarn.client.api.impl">
  <!-- start class org.apache.hadoop.yarn.client.api.impl.ContainerManagementProtocolProxy.ContainerManagementProtocolProxyData -->
  <class name="ContainerManagementProtocolProxy.ContainerManagementProtocolProxyData" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ContainerManagementProtocolProxy.ContainerManagementProtocolProxyData" type="org.apache.hadoop.yarn.ipc.YarnRPC, java.lang.String, org.apache.hadoop.yarn.api.records.ContainerId, org.apache.hadoop.yarn.api.records.Token"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SecretManager.InvalidToken" type="org.apache.hadoop.security.token.SecretManager.InvalidToken"/>
    </constructor>
    <method name="getContainerManagementProtocol" return="org.apache.hadoop.yarn.api.ContainerManagementProtocol"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.impl.ContainerManagementProtocolProxy.ContainerManagementProtocolProxyData -->
  <!-- start class org.apache.hadoop.yarn.client.api.impl.NMClientImpl.StartedContainer -->
  <class name="NMClientImpl.StartedContainer" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="NMClientImpl.StartedContainer" type="org.apache.hadoop.yarn.api.records.ContainerId, org.apache.hadoop.yarn.api.records.NodeId, org.apache.hadoop.yarn.api.records.Token"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContainerId" return="org.apache.hadoop.yarn.api.records.ContainerId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNodeId" return="org.apache.hadoop.yarn.api.records.NodeId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.impl.NMClientImpl.StartedContainer -->
</package>
<package name="org.apache.hadoop.yarn.client.cli">
  <!-- start class org.apache.hadoop.yarn.client.cli.LogsCLI -->
  <class name="LogsCLI" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.Tool"/>
    <constructor name="LogsCLI"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="createYarnClient" return="org.apache.hadoop.yarn.client.api.YarnClient"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.cli.LogsCLI -->
</package>

</api>
